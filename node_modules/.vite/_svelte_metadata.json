{"compilerOptions":{"css":"external","dev":true},"configFile":"/home/raquel/Escritorio/proyecto/cine/svelte.config.js","extensions":[".svelte"],"preprocess":[{"script":"async script({ attributes, content, filename = '' }) {\n\t\t\tconst lang = /** @type {string} */ (attributes.lang);\n\t\t\tif (!supportedScriptLangs.includes(lang)) return;\n\t\t\tconst { code, map } = await transformWithEsbuild(content, filename, {\n\t\t\t\tloader: /** @type {import('vite').ESBuildOptions['loader']} */ (lang),\n\t\t\t\ttarget: 'esnext',\n\t\t\t\ttsconfigRaw: {\n\t\t\t\t\tcompilerOptions: {\n\t\t\t\t\t\t// svelte typescript needs this flag to work with type imports\n\t\t\t\t\t\timportsNotUsedAsValues: 'preserve',\n\t\t\t\t\t\tpreserveValueImports: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmapToRelative(map, filename);\n\n\t\t\treturn {\n\t\t\t\tcode,\n\t\t\t\tmap\n\t\t\t};\n\t\t}","style":"async ({ attributes, content, filename = '' }) => {\n\t\tconst lang = /** @type {string} */ (attributes.lang);\n\t\tif (!supportedStyleLangs.includes(lang)) return;\n\t\tif (!transform) {\n\t\t\t/** @type {import('vite').ResolvedConfig} */\n\t\t\tlet resolvedConfig;\n\t\t\t// @ts-expect-error special prop added if running in v-p-s\n\t\t\tif (style.__resolvedConfig) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tresolvedConfig = style.__resolvedConfig;\n\t\t\t} else if (isResolvedConfig(config)) {\n\t\t\t\tresolvedConfig = config;\n\t\t\t} else {\n\t\t\t\tresolvedConfig = await resolveConfig(\n\t\t\t\t\tconfig,\n\t\t\t\t\tprocess.env.NODE_ENV === 'production' ? 'build' : 'serve'\n\t\t\t\t);\n\t\t\t}\n\t\t\ttransform = getCssTransformFn(resolvedConfig);\n\t\t}\n\t\tconst suffix = `${lang_sep}${lang}`;\n\t\tconst moduleId = `${filename}${suffix}`;\n\t\tconst { code, map, deps } = await transform(content, moduleId);\n\t\tremoveLangSuffix(map, suffix);\n\t\tmapToRelative(map, filename);\n\t\tconst dependencies = deps ? Array.from(deps).filter((d) => !d.endsWith(suffix)) : undefined;\n\t\treturn {\n\t\t\tcode,\n\t\t\tmap: map ?? undefined,\n\t\t\tdependencies\n\t\t};\n\t}"},"function sveltePreprocess(_a) {\n    var _b, _c;\n    var { aliases, markupTagName = 'template', preserve = [], sourceMap = (_c = ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.NODE_ENV) === 'development') !== null && _c !== void 0 ? _c : false, ...rest } = _a === void 0 ? {} : _a;\n    const transformers = rest;\n    if (aliases === null || aliases === void 0 ? void 0 : aliases.length) {\n        (0, language_1.addLanguageAlias)(aliases);\n    }\n    function resolveLanguageArgs(lang, alias) {\n        const langOpts = transformers[lang];\n        const aliasOpts = alias ? transformers[alias] : undefined;\n        const opts = {};\n        if (typeof langOpts === 'object') {\n            Object.assign(opts, langOpts);\n        }\n        Object.assign(opts, (0, language_1.getLanguageDefaults)(lang), (0, language_1.getLanguageDefaults)(alias));\n        if (lang !== alias && typeof aliasOpts === 'object') {\n            Object.assign(opts, aliasOpts);\n        }\n        if (sourceMap && lang in language_1.SOURCE_MAP_PROP_MAP) {\n            const [path, value] = language_1.SOURCE_MAP_PROP_MAP[lang];\n            (0, utils_1.setProp)(opts, path, value);\n        }\n        return opts;\n    }\n    function getTransformerOptions(lang, alias, { ignoreAliasOverride } = {}) {\n        if (lang == null)\n            return null;\n        const langOpts = transformers[lang];\n        const aliasOpts = alias ? transformers[alias] : undefined;\n        if (!ignoreAliasOverride && typeof aliasOpts === 'function') {\n            return aliasOpts;\n        }\n        if (typeof langOpts === 'function')\n            return langOpts;\n        if (aliasOpts === false || langOpts === false)\n            return false;\n        return resolveLanguageArgs(lang, alias);\n    }\n    const getTransformerTo = (type, targetLanguage) => async (svelteFile) => {\n        let { content, markup, filename, lang, alias, dependencies, attributes } = await (0, tagInfo_1.getTagInfo)(svelteFile);\n        if (lang == null || alias == null) {\n            alias = TARGET_LANGUAGES[type];\n            lang = (0, language_1.getLanguageFromAlias)(alias);\n        }\n        if ((lang && preserve.includes(lang)) || preserve.includes(alias)) {\n            return { code: content };\n        }\n        const transformerOptions = getTransformerOptions(lang, alias);\n        content = (0, prepareContent_1.prepareContent)({\n            options: transformerOptions,\n            content,\n        });\n        if (lang === targetLanguage) {\n            // has override method for alias\n            // example: sugarss override should work apart from postcss\n            if (typeof transformerOptions === 'function' && alias !== lang) {\n                return transformerOptions({ content, filename, attributes });\n            }\n            // otherwise, we're done here\n            return { code: content, dependencies };\n        }\n        const transformed = await (0, exports.transform)(lang, transformerOptions, {\n            content,\n            markup,\n            filename,\n            attributes,\n        });\n        return {\n            ...transformed,\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\n        };\n    };\n    const scriptTransformer = getTransformerTo('script', 'javascript');\n    const cssTransformer = getTransformerTo('style', 'css');\n    const markupTransformer = getTransformerTo('markup', 'html');\n    const markup = async ({ content, filename }) => {\n        if (transformers.replace) {\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\n                content,\n                markup: content,\n                filename,\n            });\n            content = transformed.code;\n        }\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\n            // we only pass the markupTagName because the rest of options\n            // is fetched internally by the `markupTransformer`\n            markupTagName,\n        });\n    };\n    const script = async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await scriptTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies, diagnostics } = transformResult;\n        if (transformers.babel) {\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\n        }\n        return { code, map, dependencies, diagnostics };\n    };\n    const style = async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await cssTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies } = transformResult;\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\n        // istanbul ignore else\n        if (hasPostcss) {\n            if (transformers.postcss) {\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \n                // todo: this seems wrong and ugly\n                { ignoreAliasOverride: true });\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\n                    content: code,\n                    markup: fullMarkup,\n                    map,\n                    filename,\n                    attributes,\n                });\n                code = transformed.code;\n                map = transformed.map;\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            }\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n        }\n        else if ('global' in attributes) {\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\n        }\n        return { code, map, dependencies };\n    };\n    return {\n        markup,\n        script,\n        style,\n    };\n}"]}